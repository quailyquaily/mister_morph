---
status: draft
---

# Feature: Standardized Run Metadata Injection

Date: 2026-02-03

## Summary
Introduce a **standard, reusable mechanism** to attach **structured metadata** to any agent run (cron, Telegram, daemon queue, future webhooks, etc.) and ensure that metadata is **visible to the agent model** (i.e. included in the LLM message sequence in a consistent, parseable form).

This solves two problems:
1) External triggers need a reliable way to provide context (“why is this run happening?”, “who/what triggered it?”).
2) The agent should be able to branch behavior based on trigger context (e.g. cron runs should be non-interactive and concise).

## Goals
- Provide a single, typed place to supply metadata from any run entrypoint.
- Make metadata **model-visible** in a consistent envelope.
- Keep metadata bounded, non-sensitive, and log-safe.
- Keep the envelope stable for future extension.

## Non-Goals
- Persisting full transcripts/tool I/O as metadata.
- Replacing domain-specific fields (e.g. Guard/Audit) with a generic blob.
- A public-facing CLI for metadata management.

## Design

### 1) Add a single metadata carrier to run options
Add a field to `agent.RunOptions`:
- `Meta map[string]any` (or a typed struct if preferred)

This is the **single source of truth** for metadata injection across all run entrypoints (cron, Telegram, etc.).

### 2) Inject metadata into the LLM message list
At run start, if `RunOptions.Meta` is non-empty, inject **one** additional message into the LLM message sequence **before** the task message.

Recommended injection properties:
- Exactly one message (avoid repeated/fragmented metadata).
- JSON payload with a stable envelope key to prevent collisions.
- Bounded size; truncate large metadata.

Suggested envelope:
```json
{
  "mister_morph_meta": {
    "trigger": "cron",
    "cron_job_id": "4b3a0f59-b6c2-4c8c-9b2c-0d9d68bd9a10",
    "cron_run_id": "c6d9f1a6-0f1b-4f9b-a3a8-1d6e7a2e9c01",
    "scheduled_for_utc": "2026-02-03T09:00:00Z",
    "telegram_chat_id": 28036192
  }
}
```

Role choice:
- Use `user` for the injected metadata message to avoid changing the global system rules.

Implementation note:
- The existing `agent.Hook` mechanism can inject this message at `step=0` by modifying the `messages` slice before the first LLM call.
- Alternative: inject in `Engine.Run` right after building the initial `messages` slice.

### 3) Size limit and truncation
Hard limit: **4 KB** for the injected metadata message payload.

If the serialized JSON exceeds the limit:
- Truncate (best-effort) by dropping non-essential keys (implementation-defined), then re-serialize.
- If it still exceeds the limit, replace with a minimal stub:
  - `mister_morph_meta.trigger`
  - `mister_morph_meta.correlation_id` (if present)
  - `mister_morph_meta.truncated=true`

### 4) Single source of metadata (current scope)
In the current scope, metadata should be supplied by a **single entrypoint** (the component that starts the run) and passed in `RunOptions.Meta`.

If, in the future, multiple components need to contribute metadata (e.g. transport layer adds correlation ids; cron adds scheduling fields), define explicit merge rules. Until then, avoid multi-source merging to keep behavior predictable.

## Security & Privacy Guidelines
Metadata is model-visible by design, so it must be treated like prompt content.

Rules:
- Do not include secrets (tokens, API keys, passwords).
- Do not include large raw user content; reference by id if needed.
- Keep identifiers minimal; avoid PII unless required.
- Consider integrating Guard redaction if metadata can contain user-provided fields.

## Agent Awareness (Required)
The agent must be explicitly instructed to treat injected metadata as **run context**, not as user instructions.

Update the system prompt rules (see `agent.DefaultPromptSpec`) to include a rule like:
- If you receive a `user` message whose content is valid JSON containing top-level key `mister_morph_meta`, you MUST:
  - treat it as contextual metadata for this run,
  - incorporate it into decisions (e.g. `trigger=cron` implies non-interactive scheduled execution),
  - NOT treat it as a request to perform actions by itself.

## Suggested Core Keys
Common:
- `trigger`: `"cron" | "telegram" | "daemon" | ...`
- `run_id`: agent run id (if applicable)
- `requested_at_utc`: RFC3339 timestamp
- `correlation_id`: for cross-system tracing

Cron:
- `cron_job_id`, `cron_run_id`
- `scheduled_for_utc`

Telegram (if enabled):
- `telegram_chat_id`
- `telegram_message_id`
- `telegram_chat_type`
- `telegram_from_user_id`

## Open Questions (Confirm When Implementing)
- Collision/merge policy if multi-source metadata is introduced later.

## TODO
- [x] Add `Meta map[string]any` to `agent.RunOptions`
- [x] Inject `RunOptions.Meta` as a single `user` message (JSON envelope) before the task message
- [x] Enforce 4 KB max payload; truncate by dropping keys; fall back to minimal stub + `truncated=true`
- [x] Add system-prompt rule so the model reliably recognizes and uses `mister_morph_meta` as context (not instructions)
- [x] Add tests covering: injection order (meta before task), truncation behavior, and rule presence in system prompt
