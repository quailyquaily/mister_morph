---
date: 2026-02-06
title: Mesh Agent Exchange Protocol (v1)
status: draft
---

# Mesh Agent Exchange Protocol (MAEP) v1

## 1) Summary
v1 targets a minimum viable end-to-end loop:
- Verifiable node identity (based on libp2p `peer_id`).
- Local contacts management (no online directory service).
- libp2p peer-to-peer communication (direct first, relay fallback).
- JSON-RPC data exchange (minimal method set in v1).
- Encrypted transport sessions (relay cannot decrypt business payloads).

Notes:
- v1 1v1 E2EE depends on libp2p secure channels.
- v1 does not include asynchronous session bootstrapping via X3DH / Double Ratchet, nor per-message ratcheting.

## 2) Goals
- Allow two agents to complete secure online data exchange after exchanging contact cards.
- Automatically fall back to relay when direct connection fails.
- Ensure `node_uuid` is never treated as a standalone identity credential.
- Keep implementation behavior consistent and avoid cross-language interoperability drift.

## 3) Non-Goals
- No online directory service.
- No group E2EE.
- No durable retransmission queue.
- No exactly-once guarantee.
- No x402 billing flow (deferred to v2).

## 4) Terminology
- `peer_id`: libp2p Peer ID (protocol-layer identity used for auth and connection matching).
- `node_id`: business namespace identifier, defined as `maep:<peer_id>`, used only for display/logging/cross-system references.
- `node_uuid`: business alias (UUIDv7), used only for contact lookup and display.
- `identity_keypair`: local Ed25519 identity keypair.
- `identity_pub_ed25519`: externally shared Ed25519 public key.

Normative requirements:
- Any identity-equality check must compare `peer_id`, never `node_uuid`.
- `peer_id` must be parsed/derived via libp2p SDK APIs; custom hash implementations are forbidden.

## 5) Identity And Contact Card

### 5.1 Identity Fields
- `node_uuid`
- `peer_id`
- `node_id` (optional derived value: `maep:<peer_id>`)
- `identity_pub_ed25519`

Implementation requirement:
- The local libp2p host must use the same `identity_keypair` as its host identity key.
- Otherwise, runtime `RemotePeer()` may diverge from the contact card `peer_id`, causing interop failures.

### 5.2 Contact Card Schema
Recommended fields:
- `version`
- `node_uuid`
- `peer_id`
- `node_id`
- `identity_pub_ed25519`
- `addresses`
- `min_supported_protocol`
- `max_supported_protocol`
- `issued_at`
- `expires_at` (recommended)
- `key_rotation_of` (optional)

Encoding rules:
- `identity_pub_ed25519`: base64url (no padding) encoding of Ed25519 public key bytes.
- `sig`: base64url (no padding) encoding of detached signature bytes.
- `addresses`: multiaddr; each address must end with `/p2p/<peer_id>`.
  Note: relay segments are allowed in the middle (for example `/p2p/<relay_peer_id>/p2p-circuit/...`).

JSON/JCS constraints (hardcoded for MVP):
- `null` is not allowed.
- Floating-point numbers are not allowed (only integer numeric type).
- Duplicate keys are not allowed.
- In JSON-RPC request/response parsing paths, any violation above returns `ERR_INVALID_JSON_PROFILE`.
- In contact-card import paths, payload/structure violations are unified as `ERR_INVALID_CONTACT_CARD` (more granular causes may still be logged).
- `identity_pub_ed25519` must decode via base64url to exactly 32 bytes (Ed25519 raw public key).
- `DerivePeerID`, fingerprinting, and signature verification must always use decoded raw bytes as input.

JCS example (`sig` excluded from signed object):
```json
{
  "payload": {
    "version": 1,
    "node_uuid": "0194f5c0-8f6e-7d9d-a4d7-6d8d4f35f456",
    "peer_id": "12D3KooWabc",
    "node_id": "maep:12D3KooWabc",
    "identity_pub_ed25519": "cHVibGljLWtleS1ieXRlcy1iYXNlNjR1cmw",
    "addresses": ["/ip4/203.0.113.8/udp/4001/quic-v1/p2p/12D3KooWabc"],
    "min_supported_protocol": 1,
    "max_supported_protocol": 1,
    "issued_at": "2026-02-06T16:00:00Z",
    "expires_at": "2026-08-06T16:00:00Z"
  },
  "sig_alg": "ed25519",
  "sig_format": "jcs-rfc8785-detached",
  "sig": "base64url_signature"
}
```

The `peer_id` above is intentionally truncated for readability; real payloads must use the full peer-id string.

Recommended signing input:
- `"maep-contact-card-v1\n" + canonical_json_bytes(payload)`

### 5.3 Import-Time Validation (Offline)
Contact-card import must cover all checks below (implementation order may vary):
1. Validate `expires_at` (if present and already expired, reject import).
2. Compute `pub = base64url_decode(identity_pub_ed25519)`; it must be 32 bytes, otherwise `ERR_INVALID_CONTACT_CARD`.
3. Build a public key object from `pub` via libp2p SDK and derive `derived_peer_id` via SDK APIs (custom implementation forbidden).
4. Parse payload `peer_id` as `expected_peer_id`; compare binary values of `derived_peer_id` and `expected_peer_id`.
5. Validate `node_id == "maep:" + peer_id` (when `node_id` is provided).
6. Validate `sig` (JCS canonical payload + domain separator).
7. Parse each `addresses` entry and verify the terminal peer component equals payload `peer_id`.
8. If local state already has the same `node_uuid` mapped to a different `peer_id`, mark as `conflicted` and forbid automatic overwrite.

### 5.4 Connect-Time Validation (Online)
Connection-time validation must perform:
1. Select `expected_peer_id` from the contact.
2. Dial only addresses containing `/p2p/<expected_peer_id>`; reject others directly.
3. After connection establishment, read `RemotePeer()` and `RemotePublicKey()` from the libp2p connection.
4. Validate `RemotePeer() == expected_peer_id`.
5. On mismatch, return `ERR_PEER_ID_MISMATCH`, disconnect immediately, and emit a high-priority security alert.

## 6) Transport And Connectivity

### 6.1 Transport Stack
- The current implementation uses libp2p default secure transport behavior (QUIC/TCP chosen by reachability and negotiation).
- Relay uses Circuit Relay v2.
- Explicit enforced QUIC-priority scheduling is not implemented yet (can be a future optimization).

### 6.2 Dial Priority
Connection order (current implementation):
1. Try direct addresses first (without `/p2p-circuit`), in input order.
2. Then try relay addresses (with `/p2p-circuit`), in input order.
3. If caller provides explicit address list, use it; otherwise use contact-saved `addresses`.
4. Automatic reordering by `last_ok_at` is not implemented yet.

### 6.3 Direct-Failure Classification
The current implementation does not emit structured failure classification codes; dial failures are returned as aggregated per-address error strings.
Actual behavior:
- Retry by address order: direct first, then relay.
- Per-address dial timeout defaults to 3 seconds (`DialAddrTimeout`).
- Identity mismatch (`peer_id_mismatch`) disconnects immediately during stream validation and returns `ERR_PEER_ID_MISMATCH`.
- A total direct-attempt budget of 8-12 seconds is not implemented yet.

### 6.4 Default Limits (MVP fixed)
- `max_rpc_request_bytes = 256 KiB`
- `max_payload_bytes = 128 KiB` (decoded bytes of `payload_base64`)
- `hello_timeout = 3s`
- `rpc_timeout_default = 10s`
- `rate_limit_data_push_per_peer = 120/min`

## 7) RPC Model

### 7.1 Protocol IDs
- `hello`: `/maep/hello/1.0.0`
- `rpc`: `/maep/rpc/1.0.0`

### 7.2 Stream Framing
v1 is fixed to one-stream-per-request:
1. Client opens `/maep/rpc/1.0.0` stream.
2. Client writes full JSON-RPC request.
3. Client half-closes write side.
4. Server returns one JSON-RPC response.
5. Stream closes.

Note:
- v1 does not support multiplexed framing.

### 7.3 Version Negotiation (`hello`)
Both sides exchange on `/maep/hello/1.0.0`:
- `protocol_min`
- `protocol_max`
- `capabilities`

`hello` stream semantics (fixed in v1):
1. Dialer opens `/maep/hello/1.0.0` stream, writes one UTF-8 JSON `hello` object, then half-closes.
2. Listener reads request, writes one UTF-8 JSON `hello` object response, and closes stream.
3. Each side computes `negotiated_protocol`; mismatch indicates implementation error and should trigger disconnect alerting.
4. `/maep/rpc/1.0.0` requests must not be processed before successful `hello` negotiation.

Negotiation rules:
- `negotiated = min(local_max, remote_max)`
- Must satisfy `negotiated >= max(local_min, remote_min)`
- If no overlap, return `ERR_UNSUPPORTED_PROTOCOL` and disconnect

Example:
```json
{
  "type": "hello",
  "protocol_min": 1,
  "protocol_max": 1,
  "capabilities": ["rpc.data.push.v1"]
}
```

### 7.4 Allowed Methods
Default allowlist:
- `agent.ping`
- `agent.capabilities.get`
- `agent.data.push`

Methods outside the allowlist must be rejected with `ERR_METHOD_NOT_ALLOWED`.

### 7.5 `agent.data.push` Semantics
`agent.data.push` is used for data exchange, including chat messages.

Request example:
```json
{
  "jsonrpc": "2.0",
  "id": "req-7f9f",
  "method": "agent.data.push",
  "params": {
    "topic": "chat.message",
    "content_type": "application/json",
    "payload_base64": "eyJtZXNzYWdlX2lkIjoibXNnXzAwMSIsInRleHQiOiLllYgiLCJzZW50X2F0IjoiMjAyNi0wMi0wNlQxNjozMDowMFoiLCJzZXNzaW9uX2lkIjoiMDE5NGY1YzAtOGY2ZS03ZDlkLWE0ZDctNmQ4ZDRmMzVmNDU2In0",
    "idempotency_key": "m-001"
  }
}
```

Notification and request rules:
- Without `id`: notification, no response.
- With `id`: return acceptance-state response, not a durability guarantee.

JSON-RPC constraints (hardcoded for MVP):
- `null` is not allowed in request/response JSON body.
- Floating-point numbers are not allowed in protocol fields (integer numeric type only).
- Violations return `ERR_INVALID_JSON_PROFILE`.
- `agent.data.push.params.content_type` must start with `application/json` (for example `application/json`, `application/json; charset=utf-8`); `text/plain` is rejected at protocol layer.
- `payload_base64` must be base64url without padding; decode failure returns `ERR_INVALID_PARAMS`.
- Decoded `payload_base64` must be an envelope JSON object and include at least:
  - `message_id` (non-empty string)
  - `text` (non-empty string)
  - `sent_at` (RFC3339 string)
- Dialogue topics (`share.proactive.v1` / `dm.checkin.v1` / `dm.reply.v1` / `chat.message`) must include `session_id`, and `session_id` must be UUIDv7.
- If decoded `payload_base64` exceeds `max_payload_bytes`, return `ERR_PAYLOAD_TOO_LARGE`.
- No protocol-level fallback: no auto conversion from plain text to envelope, and no auto-generated `session_id`. Invalid payloads are rejected directly (`ERR_INVALID_PARAMS`).

### 7.6 Business Metadata Topic (`profile.intro.v1`, planned)
Implementation status:
- Current code does not implement dedicated handling for `profile.intro.v1`.
- Current code does not persist `remote_public_nickname` (or equivalent field).
- If this topic is sent now, it is handled as ordinary `agent.data.push` envelope input.

Future design constraints:
Purpose:
- Exchange public self-profile data at business layer, such as outward-facing nickname.
- Must not participate in protocol-level auth or alter `peer_id/node_id/trust_state`.

Constraints:
- Still use `agent.data.push`.
- `content_type` must start with `application/json`.
- Decoded `payload_base64` must be envelope JSON and satisfy required fields from 7.5.

Suggested envelope example:
```json
{
  "message_id": "msg_019db8f8-7e6f-79f5-8e92-d5f4f8fd0d74",
  "text": "profile intro update",
  "sent_at": "2026-02-07T12:00:00Z",
  "profile": {
    "public_nickname": "Mochi",
    "lang": "zh-CN",
    "updated_at": "2026-02-07T12:00:00Z"
  }
}
```

Receiver-side handling recommendations:
- If `profile.public_nickname` is empty, ignore update.
- If `profile.updated_at` is not RFC3339, ignore that profile update.
- Business layer should store peer-declared nickname as `remote_public_nickname` (or equivalent), and should not forcibly overwrite local `contact_nickname`.
- If local nickname overwrite is needed, it must go through explicit business policy and emit an audit log.

Response example (acceptance state):
```json
{
  "jsonrpc": "2.0",
  "id": "req-7f9f",
  "result": {
    "accepted": true,
    "deduped": false
  }
}
```

## 8) Reliability And Idempotency
- Online semantics: best-effort + request timeout.
- Idempotency dedupe key: tuple `(from_peer_id, topic, idempotency_key)`.
- First receipt: process and record dedupe key.
- Duplicate receipt: do not process again; return `deduped=true` (when `id` exists) or silently drop (notification).
- Dedupe record TTL: default 7 days (configurable).
- Dedupe table cap: default global 10k records; evict oldest first when exceeded.

## 9) Security And Trust State

### 9.1 Relay Visibility
Visible to relay:
- Connection relationships, traffic size, timing, and online status.

Not visible to relay:
- RPC business plaintext payload.

### 9.2 Trust States
- `tofu`: cryptographic checks pass, but no second-channel verification yet.
- `verified`: second-channel fingerprint verification completed.
- `conflicted`: `node_uuid -> peer_id` conflict or critical identity mismatch.
- `revoked`: revoked; communication forbidden.

Rules:
- `tofu` is not `verified`.
- `revoked` and `conflicted` must block business communication.

### 9.3 Fingerprint Verification Flow
Fingerprint definition:
- `fingerprint = SHA256(base64url_decode(identity_pub_ed25519))` (displayed in grouped hex).

Recommended flow:
1. Set state to `tofu` after import.
2. Show short fingerprint (for example 8 groups of 4 hex chars).
3. Compare via second channel (face-to-face QR, spoken grouped code, already-verified chat channel).
4. Promote to `verified` only on full match.
5. If mismatch, set `conflicted` and alert.

Security note:
- Without second-channel verification, first-contact impersonation risk remains.

## 10) Error Codes And Handling
### 10.1 JSON-RPC Error Object
RPC errors must use standard JSON-RPC structure:
```json
{
  "jsonrpc": "2.0",
  "id": "req-7f9f",
  "error": {
    "code": -32004,
    "message": "ERR_METHOD_NOT_ALLOWED",
    "data": { "details": "method=agent.foo" }
  }
}
```

Rules:
- `error.code` must be an integer.
- `error.message` must use `ERR_*` symbols from the table below.
- Notifications (without `id`) must not return any response (including errors); only log/metrics, and disconnect if needed.
- If request parsing fails and a valid `id` is extractable, return corresponding `ERR_*` error object; otherwise log only and do not respond.

### 10.2 Symbol To JSON-RPC Code Mapping (MVP fixed)
| Symbol | JSON-RPC `error.code` |
|---|---:|
| `ERR_UNAUTHORIZED` | -32001 |
| `ERR_PEER_ID_MISMATCH` | -32002 |
| `ERR_CONTACT_CONFLICTED` | -32003 |
| `ERR_METHOD_NOT_ALLOWED` | -32004 |
| `ERR_PAYLOAD_TOO_LARGE` | -32005 |
| `ERR_RATE_LIMITED` | -32006 |
| `ERR_UNSUPPORTED_PROTOCOL` | -32007 |
| `ERR_INVALID_JSON_PROFILE` | -32008 |
| `ERR_INVALID_CONTACT_CARD` | -32009 |
| `ERR_INVALID_PARAMS` | -32602 |

### 10.3 Connection/Request Handling
| Symbol | Trigger | Connection Action | Request Action |
|---|---|---|---|
| `ERR_UNAUTHORIZED` | Remote not in contacts, or `trust_state` is `revoked/conflicted` | disconnect | reject |
| `ERR_PEER_ID_MISMATCH` | `RemotePeer() != expected_peer_id` | disconnect | reject |
| `ERR_CONTACT_CONFLICTED` | Conflict found during contact-card import (`node_uuid` mapped to different `peer_id`) | n/a | reject(import) |
| `ERR_METHOD_NOT_ALLOWED` | Method not in allowlist | keep | reject |
| `ERR_PAYLOAD_TOO_LARGE` | Exceeds payload limit | keep | reject |
| `ERR_RATE_LIMITED` | Rate limit exceeded | keep | reject |
| `ERR_INVALID_JSON_PROFILE` | `null`/floating-point/duplicate key detected | keep | reject |
| `ERR_INVALID_CONTACT_CARD` | Invalid contact-card fields (import path) | n/a | reject(import) |
| `ERR_INVALID_PARAMS` | Invalid parameter format (for example `payload_base64` decode failure) | keep | reject |
| `ERR_UNSUPPORTED_PROTOCOL` | No protocol-version overlap | disconnect | reject |

## 11) Protocol Upgrade And Downgrade

### 11.1 Compatibility Rules
- `v1.x` must remain backward compatible.
- New fields can only be added as optional.
- Unknown fields must be ignored, not rejected.
- Breaking changes require major version bump (`v2`).

### 11.2 Rollout Order
Recommended order:
1. Upgrade relay first.
2. Upgrade passive receivers next.
3. Upgrade active initiators last.

### 11.3 Downgrade Detection
Nodes should record:
- `last_remote_max_protocol`
- `last_negotiated_protocol`

Trigger `downgrade_suspected` when either condition is met:
- Current `remote_max_protocol` is lower than historical value.
- Current `negotiated_protocol` is lower than historical value.

Current implementation note:
- Current implementation does not gate on network-path changes (for example relay/address-family changes); any version decrease triggers alerting.

Default handling:
- Log high-priority warning and prompt manual verification.
- Keep connection usable.

Optional strict mode:
- Allow only `agent.ping` and `agent.capabilities.get`; temporarily disable `agent.data.push`.

## 12) Storage Model
MVP requirements:
- Provide storage abstraction interfaces first (identity / contacts / audit / dedupe / protocol history).
- Default backend uses local files (no database dependency).
- Future SQLite/other backends can be added, but must not change upper-layer protocol behavior.

Recommended file-backend partitions (logically equivalent to tables):
- `node_identity`
  - `node_uuid`, `peer_id`, `node_id`, `identity_pub_ed25519`, `identity_priv_ed25519`, `created_at`
- `contacts`
  - `node_uuid`, `peer_id`, `node_id`, `display_name`, `identity_pub_ed25519`, `addresses`, `trust_state`, `last_seen`
- `audit_events`
  - `event_id`, `action`, `peer_id`, `node_uuid`, `previous_trust_state`, `new_trust_state`, `reason`, `metadata`, `created_at`
- `dedupe_records`
  - `from_peer_id`, `topic`, `idempotency_key`, `created_at`, `expires_at`
- `protocol_history`
  - `peer_id`, `last_remote_max_protocol`, `last_negotiated_protocol`, `updated_at`

Implementation recommendations:
- Use atomic file replacement on writes (temp file + rename).
- Recommended permissions: directory `0700`, state files `0600`.

## 13) Rollout Plan
### Phase 0: Spec Freeze
- [x] Freeze `peer_id` definition and contact-card fields.
- [x] Freeze protocol IDs (`/maep/hello/1.0.0`, `/maep/rpc/1.0.0`).
- [x] Freeze error codes and disconnect strategy.
- [x] Freeze JCS signing input and default `allowed_methods` allowlist.

### Phase 1: MVP
- [x] Node identity generation and persistence (`node_uuid/peer_id/node_id`).
- [x] contacts import/export (out-of-band).
- [x] Direct-first + relay-fallback dialing.
- [x] hello negotiation + JSON-RPC one-request-per-stream.
- [x] `agent.ping` / `agent.capabilities.get` / `agent.data.push`.
- [x] trust_state and conflict-mapping enforcement.
- [x] dedupe TTL and capacity eviction.

## 14) Open Questions
- Should the default relay policy be `verified_only=false + rate limiting for tofu`, or `verified_only=true`?

## References
- Peer IDs: https://github.com/libp2p/specs/blob/master/peer-ids/peer-ids.md
- Secure Channels: https://docs.libp2p.io/concepts/secure-comm/overview/
- Circuit Relay v2: https://docs.libp2p.io/concepts/nat/circuit-relay/
- go-libp2p network API: https://pkg.go.dev/github.com/libp2p/go-libp2p/core/network
- JSON-RPC 2.0: https://www.jsonrpc.org/specification
